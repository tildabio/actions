name: 'AI Code Review'
description: 'Performs AI-powered code review on pull requests using Claude with inline comments'
author: 'Tilda Bio'

inputs:
  anthropic-api-key:
    description: 'Anthropic API key for Claude'
    required: true
  gh-token:
    description: 'GitHub token for fetching PR diff and posting review comments'
    required: true
  pr-number:
    description: 'Pull request number'
    required: true
  repository:
    description: 'Repository name in format owner/repo'
    required: true
  model:
    description: 'Claude model to use'
    required: false
    default: 'claude-sonnet-4-5-20250929'
  max-diff-size:
    description: 'Maximum diff size in characters to send for review (to control token usage)'
    required: false
    default: '100000'
  review-scope:
    description: 'What to focus the review on (bugs, security, performance, style, all)'
    required: false
    default: 'all'
  custom-prompt:
    description: 'Additional instructions to include in the review prompt'
    required: false
    default: ''

outputs:
  review-status:
    description: 'Status of the review (success, skipped, error)'
    value: ${{ steps.post-review.outputs.review_status }}
  comments-posted:
    description: 'Number of inline comments posted'
    value: ${{ steps.post-review.outputs.comments_posted }}

runs:
  using: 'composite'
  steps:
    - name: Fetch PR diff and run AI review
      id: ai-review
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.gh-token }}
        ANTHROPIC_API_KEY: ${{ inputs.anthropic-api-key }}
        PR_NUMBER: ${{ inputs.pr-number }}
        REPOSITORY: ${{ inputs.repository }}
        MODEL: ${{ inputs.model }}
        MAX_DIFF_SIZE: ${{ inputs.max-diff-size }}
        REVIEW_SCOPE: ${{ inputs.review-scope }}
        CUSTOM_PROMPT: ${{ inputs.custom-prompt }}
      run: |
        set -euo pipefail

        echo "Fetching PR #${PR_NUMBER} details from ${REPOSITORY}..."

        # Fetch PR metadata
        PR_DATA=$(gh pr view "$PR_NUMBER" --repo "$REPOSITORY" --json title,body,baseRefName,headRefName)
        PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
        PR_BODY=$(echo "$PR_DATA" | jq -r '.body // ""')
        BASE_BRANCH=$(echo "$PR_DATA" | jq -r '.baseRefName')
        HEAD_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')

        echo "PR: $PR_TITLE"
        echo "Branch: $HEAD_BRANCH -> $BASE_BRANCH"

        # Fetch the diff
        DIFF=$(gh pr diff "$PR_NUMBER" --repo "$REPOSITORY" 2>/dev/null || echo "")

        if [ -z "$DIFF" ]; then
          echo "No diff found or PR has no changes."
          echo "review_status=skipped" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        DIFF_SIZE=${#DIFF}
        echo "Diff size: $DIFF_SIZE characters"

        if [ "$DIFF_SIZE" -gt "$MAX_DIFF_SIZE" ]; then
          echo "Diff exceeds max size ($MAX_DIFF_SIZE chars). Truncating..."
          DIFF="${DIFF:0:$MAX_DIFF_SIZE}

        ... [DIFF TRUNCATED - exceeded ${MAX_DIFF_SIZE} character limit] ..."
        fi

        # Build scope instructions
        case "$REVIEW_SCOPE" in
          bugs)
            SCOPE_INSTRUCTIONS="Focus exclusively on identifying bugs, logic errors, edge cases, and potential runtime failures."
            ;;
          security)
            SCOPE_INSTRUCTIONS="Focus exclusively on security vulnerabilities: injection attacks, authentication/authorization issues, data exposure, OWASP top 10, and unsafe patterns."
            ;;
          performance)
            SCOPE_INSTRUCTIONS="Focus exclusively on performance issues: N+1 queries, unnecessary allocations, missing indexes, inefficient algorithms, and resource leaks."
            ;;
          style)
            SCOPE_INSTRUCTIONS="Focus exclusively on code style, readability, naming conventions, and adherence to best practices."
            ;;
          all|*)
            SCOPE_INSTRUCTIONS="Review for bugs, security vulnerabilities, performance issues, and code quality. Prioritize issues by severity."
            ;;
        esac

        SYSTEM_PROMPT="You are an expert code reviewer. You review pull request diffs and provide actionable inline feedback on specific lines.

        Rules:
        - Return ONLY a valid JSON object. No markdown, no explanation outside the JSON.
        - Each comment must reference the exact file path and a line number from the ADDED side of the diff (lines starting with +).
        - The line number must be the line number in the NEW file (right side of the diff), calculated from the @@ hunk headers.
        - Only flag real issues. Do not pad the review with trivial observations.
        - Be concise. Each comment body should be 1-3 sentences.
        - Prefix each comment body with a severity tag: [CRITICAL], [WARNING], [SUGGESTION], or [NITPICK].
        - If the code looks good and you have no issues to flag, return {\"summary\": \"Code looks good. No issues found.\", \"comments\": []}.

        ${SCOPE_INSTRUCTIONS}

        Response format:
        {
          \"summary\": \"Brief 1-2 sentence overall summary of the PR changes and review findings.\",
          \"comments\": [
            {
              \"path\": \"relative/path/to/file.py\",
              \"line\": 42,
              \"body\": \"[SEVERITY] Your comment here.\"
            }
          ]
        }"

        if [ -n "$CUSTOM_PROMPT" ]; then
          SYSTEM_PROMPT="${SYSTEM_PROMPT}

        Additional instructions: ${CUSTOM_PROMPT}"
        fi

        USER_PROMPT="Review this pull request and return inline comments as JSON.

        **Title:** ${PR_TITLE}
        **Description:** ${PR_BODY}
        **Branch:** ${HEAD_BRANCH} -> ${BASE_BRANCH}

        **Diff:**
        \`\`\`diff
        ${DIFF}
        \`\`\`"

        echo "Sending diff to Claude (${MODEL}) for review..."

        SYSTEM_FILE=$(mktemp)
        USER_FILE=$(mktemp)
        PAYLOAD_FILE=$(mktemp)
        RESPONSE_FILE=$(mktemp)
        trap 'rm -f "$SYSTEM_FILE" "$USER_FILE" "$PAYLOAD_FILE" "$RESPONSE_FILE"' EXIT

        printf '%s' "$SYSTEM_PROMPT" > "$SYSTEM_FILE"
        printf '%s' "$USER_PROMPT" > "$USER_FILE"

        jq -n \
          --arg model "$MODEL" \
          --arg system "$(cat "$SYSTEM_FILE")" \
          --arg user "$(cat "$USER_FILE")" \
          '{
            model: $model,
            max_tokens: 4096,
            system: $system,
            messages: [
              {
                role: "user",
                content: $user
              }
            ]
          }' > "$PAYLOAD_FILE"

        HTTP_STATUS=$(curl -s -w "%{http_code}" -o "$RESPONSE_FILE" \
          -X POST "https://api.anthropic.com/v1/messages" \
          -H "Content-Type: application/json" \
          -H "x-api-key: ${ANTHROPIC_API_KEY}" \
          -H "anthropic-version: 2023-06-01" \
          -d @"$PAYLOAD_FILE")

        if [ "$HTTP_STATUS" -ne 200 ]; then
          echo "::error::Claude API request failed with status $HTTP_STATUS"
          cat "$RESPONSE_FILE"
          echo "review_status=error" >> "$GITHUB_OUTPUT"
          exit 1
        fi

        # Extract the text content from Claude response
        REVIEW_JSON=$(jq -r '.content[0].text' "$RESPONSE_FILE")

        if [ -z "$REVIEW_JSON" ] || [ "$REVIEW_JSON" = "null" ]; then
          echo "::error::Failed to extract review from Claude response"
          cat "$RESPONSE_FILE"
          echo "review_status=error" >> "$GITHUB_OUTPUT"
          exit 1
        fi

        # Strip markdown code fences if Claude wrapped the JSON
        REVIEW_JSON=$(echo "$REVIEW_JSON" | sed 's/^```json//;s/^```//;s/```$//' | sed '/^[[:space:]]*$/d')

        # Validate it's valid JSON
        if ! echo "$REVIEW_JSON" | jq . > /dev/null 2>&1; then
          echo "::error::Claude returned invalid JSON"
          echo "$REVIEW_JSON"
          echo "review_status=error" >> "$GITHUB_OUTPUT"
          exit 1
        fi

        # Save for next step
        REVIEW_OUTPUT=$(mktemp)
        echo "$REVIEW_JSON" > "$REVIEW_OUTPUT"
        echo "review_file=$REVIEW_OUTPUT" >> "$GITHUB_OUTPUT"
        echo "review_status=success" >> "$GITHUB_OUTPUT"

        COMMENT_COUNT=$(echo "$REVIEW_JSON" | jq '.comments | length')
        SUMMARY=$(echo "$REVIEW_JSON" | jq -r '.summary')
        echo "Review generated: $COMMENT_COUNT inline comment(s)"
        echo "Summary: $SUMMARY"

    - name: Post inline review to PR
      id: post-review
      if: steps.ai-review.outputs.review_status == 'success'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.gh-token }}
        PR_NUMBER: ${{ inputs.pr-number }}
        REPOSITORY: ${{ inputs.repository }}
        REVIEW_FILE: ${{ steps.ai-review.outputs.review_file }}
      run: |
        set -euo pipefail

        REVIEW_JSON=$(cat "$REVIEW_FILE")
        SUMMARY=$(echo "$REVIEW_JSON" | jq -r '.summary')
        COMMENT_COUNT=$(echo "$REVIEW_JSON" | jq '.comments | length')

        # Fetch the latest commit SHA on the PR (required by GitHub review API)
        COMMIT_SHA=$(gh pr view "$PR_NUMBER" --repo "$REPOSITORY" --json commits --jq '.commits[-1].oid')
        echo "Latest commit: $COMMIT_SHA"

        # Build the review body
        REVIEW_BODY="## AI Code Review

        ${SUMMARY}

        ---
        *${COMMENT_COUNT} inline comment(s) | Powered by Claude*"

        if [ "$COMMENT_COUNT" -eq 0 ]; then
          # No inline comments — just post the summary as a PR comment
          COMMENT_FILE=$(mktemp)
          trap 'rm -f "$COMMENT_FILE"' EXIT
          printf '%s' "$REVIEW_BODY" > "$COMMENT_FILE"
          gh pr comment "$PR_NUMBER" --repo "$REPOSITORY" --body-file "$COMMENT_FILE"
          echo "Posted summary comment (no inline issues found)"
          echo "review_status=success" >> "$GITHUB_OUTPUT"
          echo "comments_posted=0" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # Build the review payload with inline comments
        PAYLOAD_FILE=$(mktemp)
        trap 'rm -f "$PAYLOAD_FILE"' EXIT

        # Extract comments array and build the GitHub review API payload
        echo "$REVIEW_JSON" | jq \
          --arg sha "$COMMIT_SHA" \
          --arg body "$REVIEW_BODY" \
          '{
            commit_id: $sha,
            body: $body,
            event: "COMMENT",
            comments: [
              .comments[] | {
                path: .path,
                line: .line,
                side: "RIGHT",
                body: .body
              }
            ]
          }' > "$PAYLOAD_FILE"

        echo "Posting review with $COMMENT_COUNT inline comment(s)..."

        # Post the review with inline comments
        RESPONSE=$(gh api \
          --method POST \
          -H "Accept: application/vnd.github+json" \
          "/repos/${REPOSITORY}/pulls/${PR_NUMBER}/reviews" \
          --input "$PAYLOAD_FILE" 2>&1) || {
          echo "::warning::Failed to post review with inline comments. Falling back to summary comment."
          echo "$RESPONSE"

          # Fallback: post as regular comment with all findings
          FALLBACK_FILE=$(mktemp)
          {
            printf '%s\n\n' "$REVIEW_BODY"
            echo "$REVIEW_JSON" | jq -r '.comments[] | "**\(.path):\(.line)** — \(.body)\n"'
          } > "$FALLBACK_FILE"
          gh pr comment "$PR_NUMBER" --repo "$REPOSITORY" --body-file "$FALLBACK_FILE"
          rm -f "$FALLBACK_FILE"
          echo "review_status=success" >> "$GITHUB_OUTPUT"
          echo "comments_posted=$COMMENT_COUNT" >> "$GITHUB_OUTPUT"
          exit 0
        }

        echo "Review posted successfully with $COMMENT_COUNT inline comment(s)"
        echo "review_status=success" >> "$GITHUB_OUTPUT"
        echo "comments_posted=$COMMENT_COUNT" >> "$GITHUB_OUTPUT"

branding:
  icon: 'eye'
  color: 'purple'
