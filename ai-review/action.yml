name: 'AI Code Review'
description: 'AI code review on pull requests using Claude — CRITICAL issues only, inline comments, incremental on sync'
author: 'Tilda Bio'

inputs:
  anthropic-api-key:
    description: 'Anthropic API key for Claude'
    required: true
  gh-token:
    description: 'GitHub token for fetching PR diff and posting review comments'
    required: true
  pr-number:
    description: 'Pull request number'
    required: true
  repository:
    description: 'Repository name in format owner/repo'
    required: true
  model:
    description: 'Claude model to use'
    required: false
    default: 'claude-sonnet-4-5-20250929'
  max-diff-size:
    description: 'Maximum diff size in characters (to control token usage)'
    required: false
    default: '100000'
  context-file:
    description: 'Path to a repo-specific context file (e.g. .github/AI_CONTEXT.md). Requires checkout.'
    required: false
    default: ''
  custom-prompt:
    description: 'Additional instructions appended to the review prompt'
    required: false
    default: ''
  bot-username:
    description: 'GitHub username of the bot posting reviews (for deduplication)'
    required: false
    default: 'ojasgo'

outputs:
  review-status:
    description: 'Status of the review (success, skipped, error)'
    value: ${{ steps.run-review.outputs.review_status }}
  comments-posted:
    description: 'Number of comments posted'
    value: ${{ steps.run-review.outputs.comments_posted }}

runs:
  using: 'composite'
  steps:
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Run AI review
      id: run-review
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.gh-token }}
        ANTHROPIC_API_KEY: ${{ inputs.anthropic-api-key }}
        PR_NUMBER: ${{ inputs.pr-number }}
        REPOSITORY: ${{ inputs.repository }}
        MODEL: ${{ inputs.model }}
        MAX_DIFF_SIZE: ${{ inputs.max-diff-size }}
        CONTEXT_FILE: ${{ inputs.context-file }}
        CUSTOM_PROMPT: ${{ inputs.custom-prompt }}
        BOT_USERNAME: ${{ inputs.bot-username }}
      run: |
        python3 << 'PYEOF'
        import json
        import os
        import subprocess
        import sys
        import textwrap
        import urllib.request
        import urllib.error

        # ─── Config ───────────────────────────────────────────────────────
        PR_NUMBER      = os.environ["PR_NUMBER"]
        REPOSITORY     = os.environ["REPOSITORY"]
        MODEL          = os.environ["MODEL"]
        MAX_DIFF_SIZE  = int(os.environ["MAX_DIFF_SIZE"])
        CONTEXT_FILE   = os.environ.get("CONTEXT_FILE", "")
        CUSTOM_PROMPT  = os.environ.get("CUSTOM_PROMPT", "")
        BOT_USERNAME   = os.environ.get("BOT_USERNAME", "ojasgo")
        ANTHROPIC_KEY  = os.environ["ANTHROPIC_API_KEY"]

        def gh(*args):
            r = subprocess.run(["gh"] + list(args), capture_output=True, text=True, timeout=120)
            if r.returncode != 0:
                print(f"gh error: {' '.join(args)}\n{r.stderr}", file=sys.stderr)
            return r.stdout.strip()

        def out(key, val):
            with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                f.write(f"{key}={val}\n")

        # ─── 1. PR metadata ──────────────────────────────────────────────
        print(f"Fetching PR #{PR_NUMBER}...")
        pr = json.loads(gh("pr", "view", PR_NUMBER, "--repo", REPOSITORY,
                           "--json", "title,body,baseRefName,headRefName,commits"))
        pr_title    = pr["title"]
        pr_body     = (pr.get("body") or "")[:2000]
        base_branch = pr["baseRefName"]
        head_branch = pr["headRefName"]
        commits     = pr.get("commits", [])
        head_sha    = commits[-1]["oid"] if commits else ""
        print(f"  {head_branch} -> {base_branch} ({len(commits)} commits, HEAD {head_sha[:8]})")

        # ─── 2. Check for previous AI review ─────────────────────────────
        # Use issue comments (not review comments) to track last reviewed SHA.
        # We embed <!-- ai-review-sha:XXXX --> in our comment body.
        import re as _re
        print("Checking for previous AI reviews...")
        raw = gh("api", f"repos/{REPOSITORY}/issues/{PR_NUMBER}/comments", "--paginate")
        issue_comments = json.loads(raw) if raw else []

        last_reviewed_sha = None
        for c in issue_comments:
            if c.get("user", {}).get("login") == BOT_USERNAME:
                body = c.get("body", "")
                m = _re.search(r'<!-- ai-review-sha:([a-f0-9]+) -->', body)
                if m:
                    last_reviewed_sha = m.group(1)

        print(f"  Last reviewed SHA: {last_reviewed_sha[:8] if last_reviewed_sha else 'none'}, HEAD: {head_sha[:8]}")

        # ─── 3. Get diff ─────────────────────────────────────────────────
        incremental = False
        if last_reviewed_sha == head_sha:
            print("  Already reviewed this commit. Skipping.")
            out("review_status", "skipped"); out("comments_posted", "0"); sys.exit(0)
        elif last_reviewed_sha:
            print(f"  Incremental diff: {last_reviewed_sha[:8]}..{head_sha[:8]}")
            diff = gh("api", f"repos/{REPOSITORY}/compare/{last_reviewed_sha}...{head_sha}",
                      "--jq", '.files[]? | "diff --git a/" + .filename + " b/" + .filename + "\\n" + (.patch // "")')
            if diff:
                incremental = True
            else:
                print("  No new changes since last review. Skipping.")
                out("review_status", "skipped"); out("comments_posted", "0"); sys.exit(0)
        else:
            print("  First review — full PR diff.")
            diff = gh("pr", "diff", PR_NUMBER, "--repo", REPOSITORY)

        if not diff:
            print("  Empty diff."); out("review_status", "skipped"); out("comments_posted", "0"); sys.exit(0)

        print(f"  Diff: {len(diff)} chars (incremental={incremental})")
        if len(diff) > MAX_DIFF_SIZE:
            diff = diff[:MAX_DIFF_SIZE] + "\n\n... [DIFF TRUNCATED] ..."

        # ─── 4. Read repo context file ────────────────────────────────────
        repo_context = ""
        if CONTEXT_FILE and os.path.isfile(CONTEXT_FILE):
            with open(CONTEXT_FILE) as f:
                repo_context = f.read()
            print(f"  Loaded context from {CONTEXT_FILE} ({len(repo_context)} chars)")

        # ─── 5. Build prompt ──────────────────────────────────────────────
        system_prompt = textwrap.dedent("""\
            You are a senior code reviewer. You ONLY report CRITICAL issues — bugs, security vulnerabilities, data loss, and crashes that MUST be fixed before merge.

            RULES:
            - ONLY comment on issues that will cause bugs, security holes, data loss, or crashes in production.
            - Do NOT comment on style, naming, formatting, missing docs, type hints, or import ordering.
            - Do NOT suggest alternatives, improvements, or "consider doing X".
            - Do NOT comment on things that require full codebase context to verify.
            - Do NOT nitpick. If you are not 90%+ confident it is a real production issue, do NOT comment.
            - If no critical issues: return {"comments": []}
            - Return ONLY valid JSON. No markdown fences, no explanation outside JSON.

            WHAT IS CRITICAL:
            - Hardcoded secrets/passwords/API keys
            - Injection vulnerabilities (SQL, Cypher, command, prompt)
            - Silent exception swallowing on critical paths (data loss)
            - Command injection via shell=True or os.system with user input
            - Missing timeout on external calls (can hang forever)
            - PubSub messages ACKed before processing (data loss)
            - Removed safety checks (validation, bounds, cleanup) without replacement
            - Race conditions that cause data corruption
            - Breaking changes to shared libraries without downstream updates

            WHAT IS NOT CRITICAL (do NOT comment):
            - Code style, naming conventions, formatting
            - Missing error logging (unless it hides data loss)
            - "Consider using X" suggestions
            - Hypothetical issues
            - Performance unless it causes OOM or timeout
            - Missing tests
            - Import ordering, unused imports
            - Commented-out code

            Response format:
            {
              "comments": [
                {"path": "file.go", "line": 42, "body": "Description of the critical issue and how to fix it."}
              ]
            }""")

        if repo_context:
            system_prompt += "\n\nREPO CONTEXT:\n" + repo_context

        if CUSTOM_PROMPT:
            system_prompt += "\n\nADDITIONAL INSTRUCTIONS:\n" + CUSTOM_PROMPT

        label = "incremental (new commits only)" if incremental else "full PR"
        user_prompt = textwrap.dedent(f"""\
            Review this {label} diff. Return JSON only. Only CRITICAL issues.

            Title: {pr_title}
            Description: {pr_body}
            Branch: {head_branch} -> {base_branch}

            Diff:
            ```diff
            {diff}
            ```""")

        # ─── 6. Call Claude ───────────────────────────────────────────────
        print(f"Calling Claude ({MODEL})...")
        payload = {
            "model": MODEL,
            "max_tokens": 4096,
            "system": system_prompt,
            "messages": [{"role": "user", "content": user_prompt}]
        }

        req = urllib.request.Request(
            "https://api.anthropic.com/v1/messages",
            data=json.dumps(payload).encode(),
            headers={
                "Content-Type": "application/json",
                "x-api-key": ANTHROPIC_KEY,
                "anthropic-version": "2023-06-01",
            },
            method="POST"
        )

        try:
            with urllib.request.urlopen(req, timeout=120) as resp:
                resp_data = json.loads(resp.read())
        except urllib.error.HTTPError as e:
            body = e.read().decode() if e.fp else ""
            print(f"::error::Claude API HTTP {e.code}: {body}")
            out("review_status", "error"); out("comments_posted", "0"); sys.exit(1)

        text = resp_data.get("content", [{}])[0].get("text", "")

        # Strip code fences
        if text.startswith("```"):
            lines = text.split("\n")
            if lines[0].startswith("```"): lines = lines[1:]
            if lines and lines[-1].strip() == "```": lines = lines[:-1]
            text = "\n".join(lines)

        try:
            review = json.loads(text)
        except json.JSONDecodeError:
            print(f"::error::Invalid JSON from Claude:\n{text[:500]}")
            out("review_status", "error"); out("comments_posted", "0"); sys.exit(1)

        comments = review.get("comments", [])
        print(f"  Claude returned {len(comments)} comment(s)")

        # ─── 7. Post results ──────────────────────────────────────────────
        # Single issue comment — no threads to resolve, no merge blockers.
        # Embed SHA marker for incremental tracking on next push.
        if not comments:
            print("  No critical issues found.")
            cf = "/tmp/ai_review_comment.md"
            with open(cf, "w") as f:
                f.write(f"## AI Code Review\n\nNo critical issues found.\n\n<!-- ai-review-sha:{head_sha} -->")
            gh("pr", "comment", PR_NUMBER, "--repo", REPOSITORY, "--body-file", cf)
            out("review_status", "success"); out("comments_posted", "0"); sys.exit(0)

        label = "new changes only" if incremental else "full diff"
        lines = [f"## AI Code Review ({label})\n"]
        for i, c in enumerate(comments, 1):
            path = c.get("path", "")
            line = c.get("line", 0)
            body = c.get("body", "")
            lines.append(f"**{i}. `{path}:{line}`**")
            lines.append(f"> {body}\n")

        lines.append(f"\n<!-- ai-review-sha:{head_sha} -->")
        comment_body = "\n".join(lines)

        cf = "/tmp/ai_review_comment.md"
        with open(cf, "w") as f:
            f.write(comment_body)

        gh("pr", "comment", PR_NUMBER, "--repo", REPOSITORY, "--body-file", cf)
        print(f"  Posted comment with {len(comments)} finding(s)")
        out("review_status", "success"); out("comments_posted", str(len(comments)))

        PYEOF

branding:
  icon: 'eye'
  color: 'purple'
