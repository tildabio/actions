name: 'AI Code Review'
description: 'AI code review on pull requests using Claude — policy-driven via repo REVIEW.md, inline comments, incremental on sync'
author: 'Tilda Bio'

inputs:
  anthropic-api-key:
    description: 'Anthropic API key for Claude'
    required: true
  gh-token:
    description: 'GitHub token for fetching PR diff and posting review comments'
    required: true
  pr-number:
    description: 'Pull request number'
    required: true
  repository:
    description: 'Repository name in format owner/repo'
    required: true
  model:
    description: 'Claude model to use'
    required: false
    default: 'claude-sonnet-4-5-20250929'
  max-diff-size:
    description: 'Maximum diff size in characters (to control token usage)'
    required: false
    default: '100000'
  context-file:
    description: 'Path to repo REVIEW.md that defines review policy (severities, categories, rules). Requires checkout.'
    required: true
  repo-context:
    description: 'Path to repo context file (e.g. AI_CONTEXT.md) with architecture details. Requires checkout.'
    required: false
    default: ''
  bot-username:
    description: 'GitHub username of the bot posting reviews (for deduplication)'
    required: false
    default: 'ojasgo'

outputs:
  review-status:
    description: 'Status of the review (success, skipped, error)'
    value: ${{ steps.run-review.outputs.review_status }}
  comments-posted:
    description: 'Number of comments posted'
    value: ${{ steps.run-review.outputs.comments_posted }}

runs:
  using: 'composite'
  steps:
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Run AI review
      id: run-review
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.gh-token }}
        ANTHROPIC_API_KEY: ${{ inputs.anthropic-api-key }}
        PR_NUMBER: ${{ inputs.pr-number }}
        REPOSITORY: ${{ inputs.repository }}
        MODEL: ${{ inputs.model }}
        MAX_DIFF_SIZE: ${{ inputs.max-diff-size }}
        CONTEXT_FILE: ${{ inputs.context-file }}
        REPO_CONTEXT: ${{ inputs.repo-context }}
        BOT_USERNAME: ${{ inputs.bot-username }}
      run: |
        python3 << 'PYEOF'
        import json
        import os
        import subprocess
        import sys
        import textwrap
        import urllib.request
        import urllib.error

        # ─── Config ───────────────────────────────────────────────────────
        PR_NUMBER      = os.environ["PR_NUMBER"]
        REPOSITORY     = os.environ["REPOSITORY"]
        MODEL          = os.environ["MODEL"]
        MAX_DIFF_SIZE  = int(os.environ["MAX_DIFF_SIZE"])
        CONTEXT_FILE   = os.environ["CONTEXT_FILE"]
        REPO_CONTEXT   = os.environ.get("REPO_CONTEXT", "")
        BOT_USERNAME   = os.environ.get("BOT_USERNAME", "ojasgo")
        ANTHROPIC_KEY  = os.environ["ANTHROPIC_API_KEY"]

        def gh(*args):
            r = subprocess.run(["gh"] + list(args), capture_output=True, text=True, timeout=120)
            if r.returncode != 0:
                print(f"gh error: {' '.join(args)}\n{r.stderr}", file=sys.stderr)
            return r.stdout.strip()

        def out(key, val):
            with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                f.write(f"{key}={val}\n")

        # ─── 1. PR metadata ──────────────────────────────────────────────
        print(f"Fetching PR #{PR_NUMBER}...")
        pr = json.loads(gh("pr", "view", PR_NUMBER, "--repo", REPOSITORY,
                           "--json", "title,body,baseRefName,headRefName,commits"))
        pr_title    = pr["title"]
        pr_body     = (pr.get("body") or "")[:2000]
        base_branch = pr["baseRefName"]
        head_branch = pr["headRefName"]
        commits     = pr.get("commits", [])
        head_sha    = commits[-1]["oid"] if commits else ""
        print(f"  {head_branch} -> {base_branch} ({len(commits)} commits, HEAD {head_sha[:8]})")

        # ─── 2. Check for previous AI review ─────────────────────────────
        # Use issue comments (not review comments) to track last reviewed SHA.
        # We embed <!-- ai-review-sha:XXXX --> in our comment body.
        import re as _re
        print("Checking for previous AI reviews...")
        raw = gh("api", f"repos/{REPOSITORY}/issues/{PR_NUMBER}/comments", "--paginate")
        issue_comments = json.loads(raw) if raw else []

        last_reviewed_sha = None
        for c in issue_comments:
            if c.get("user", {}).get("login") == BOT_USERNAME:
                body = c.get("body", "")
                m = _re.search(r'<!-- ai-review-sha:([a-f0-9]+) -->', body)
                if m:
                    last_reviewed_sha = m.group(1)

        print(f"  Last reviewed SHA: {last_reviewed_sha[:8] if last_reviewed_sha else 'none'}, HEAD: {head_sha[:8]}")

        # ─── 3. Get diff ─────────────────────────────────────────────────
        incremental = False
        if last_reviewed_sha == head_sha:
            print("  Already reviewed this commit. Skipping.")
            out("review_status", "skipped"); out("comments_posted", "0"); sys.exit(0)
        elif last_reviewed_sha:
            print(f"  Incremental diff: {last_reviewed_sha[:8]}..{head_sha[:8]}")
            diff = gh("api", f"repos/{REPOSITORY}/compare/{last_reviewed_sha}...{head_sha}",
                      "--jq", '.files[]? | "diff --git a/" + .filename + " b/" + .filename + "\\n" + (.patch // "")')
            if diff:
                incremental = True
            else:
                print("  No new changes since last review. Skipping.")
                out("review_status", "skipped"); out("comments_posted", "0"); sys.exit(0)
        else:
            print("  First review — full PR diff.")
            diff = gh("pr", "diff", PR_NUMBER, "--repo", REPOSITORY)

        if not diff:
            print("  Empty diff."); out("review_status", "skipped"); out("comments_posted", "0"); sys.exit(0)

        print(f"  Diff: {len(diff)} chars (incremental={incremental})")
        if len(diff) > MAX_DIFF_SIZE:
            diff = diff[:MAX_DIFF_SIZE] + "\n\n... [DIFF TRUNCATED] ..."

        # ─── 4. Read REVIEW.md ──────────────────────────────────────────
        if not CONTEXT_FILE or not os.path.isfile(CONTEXT_FILE):
            print(f"::error::context-file not found: '{CONTEXT_FILE}'. Each repo must provide a REVIEW.md.")
            out("review_status", "error"); out("comments_posted", "0"); sys.exit(1)

        with open(CONTEXT_FILE) as f:
            review_policy = f.read()
        print(f"  Loaded review policy from {CONTEXT_FILE} ({len(review_policy)} chars)")

        repo_architecture = ""
        if REPO_CONTEXT and os.path.isfile(REPO_CONTEXT):
            with open(REPO_CONTEXT) as f:
                repo_architecture = f.read()
            print(f"  Loaded repo context from {REPO_CONTEXT} ({len(repo_architecture)} chars)")

        # ─── 5. Build prompt ──────────────────────────────────────────────
        system_prompt = textwrap.dedent("""\
            You are a senior code reviewer.

            RESPONSE FORMAT:
            - Return ONLY valid JSON. No markdown fences, no explanation outside JSON.
            - If no issues worth reporting: return {"comments": []}
            - Each comment MUST have these 4 fields:
            {
              "comments": [
                {
                  "path": "src/api/helpers.py",
                  "line": 42,
                  "category": "free-form string — use the severity or category from the review guidelines",
                  "body": "Concise description of the problem (1-4 lines). No fix suggestion, no preamble."
                }
              ]
            }

            IMPORTANT:
            - "category" is a free-form string — use whatever severity level or category name the review guidelines specify
            - "body" should be concise (1-4 lines) — describe the problem only, no fix suggestion, no preamble
            - Do NOT prefix body with the category label — the category field handles that""")

        system_prompt += "\n\nREVIEW GUIDELINES (follow these as your primary review policy):\n" + review_policy

        if repo_architecture:
            system_prompt += "\n\nREPOSITORY ARCHITECTURE (use this to understand the codebase):\n" + repo_architecture

        label = "incremental (new commits only)" if incremental else "full PR"
        user_prompt = textwrap.dedent(f"""\
            Review this {label} diff. Return JSON only. Follow the review guidelines.

            Title: {pr_title}
            Description: {pr_body}
            Branch: {head_branch} -> {base_branch}

            Diff:
            ```diff
            {diff}
            ```""")

        # ─── 6. Call Claude ───────────────────────────────────────────────
        print(f"Calling Claude ({MODEL})...")
        payload = {
            "model": MODEL,
            "max_tokens": 4096,
            "system": system_prompt,
            "messages": [{"role": "user", "content": user_prompt}]
        }

        req = urllib.request.Request(
            "https://api.anthropic.com/v1/messages",
            data=json.dumps(payload).encode(),
            headers={
                "Content-Type": "application/json",
                "x-api-key": ANTHROPIC_KEY,
                "anthropic-version": "2023-06-01",
            },
            method="POST"
        )

        try:
            with urllib.request.urlopen(req, timeout=120) as resp:
                resp_data = json.loads(resp.read())
        except urllib.error.HTTPError as e:
            body = e.read().decode() if e.fp else ""
            print(f"::error::Claude API HTTP {e.code}: {body}")
            out("review_status", "error"); out("comments_posted", "0"); sys.exit(1)

        text = resp_data.get("content", [{}])[0].get("text", "")

        # Strip code fences
        if text.startswith("```"):
            lines = text.split("\n")
            if lines[0].startswith("```"): lines = lines[1:]
            if lines and lines[-1].strip() == "```": lines = lines[:-1]
            text = "\n".join(lines)

        try:
            review = json.loads(text)
        except json.JSONDecodeError:
            print(f"::error::Invalid JSON from Claude:\n{text[:500]}")
            out("review_status", "error"); out("comments_posted", "0"); sys.exit(1)

        comments = review.get("comments", [])
        print(f"  Claude returned {len(comments)} comment(s)")

        # ─── 7. Post results ──────────────────────────────────────────────
        # Post as PR review: summary body + inline comments on diff lines.
        # Also post an issue comment with SHA marker for incremental tracking.
        if not comments:
            print("  No issues found.")
            cf = "/tmp/ai_review_comment.md"
            with open(cf, "w") as f:
                f.write(f"No issues found.\n\n<!-- ai-review-sha:{head_sha} -->")
            gh("pr", "comment", PR_NUMBER, "--repo", REPOSITORY, "--body-file", cf)
            out("review_status", "success"); out("comments_posted", "0"); sys.exit(0)

        # Category emoji mapping
        CAT_EMOJI = {
            # Severity levels
            "critical": "\U0001f6d1",
            "high": "\U0001f534",
            "medium": "\U0001f7e0",
            "low": "\U0001f7e1",
            # Original categories
            "security": "\U0001f6e1\ufe0f",
            "injection": "\U0001f489",
            "credentials": "\U0001f511",
            "data loss": "\U0001f4a5",
            "reliability": "\u26a0\ufe0f",
            # REVIEW.md categories
            "concurrency": "\U0001f500",
            "performance": "\u26a1",
            "design": "\U0001f4d0",
            "go-specific": "\U0001f439",
            "python/ai": "\U0001f40d",
            "neo4j/cypher": "\U0001f4c0",
            "database/migration": "\U0001f5c4\ufe0f",
            "k8s": "\u2638\ufe0f",
            "test coverage": "\U0001f9ea",
            "monorepo/cross-service": "\U0001f517",
            "breaking change": "\U0001f4a3",
            "correctness": "\u2705",
            "error handling": "\U0001f6a8",
        }

        def fmt_category(cat):
            key = (cat or "").lower()
            emoji = CAT_EMOJI.get(key, "\U0001f534")
            return f"{emoji} {cat}"

        # Build inline review comments for the diff
        review_comments = []
        for c in comments:
            path = c.get("path", "")
            line_num = c.get("line", 0)
            body = c.get("body", "")
            cat = c.get("category", "")
            if path and line_num and body:
                inline_body = f"{fmt_category(cat)}\n\n{body}"
                review_comments.append({
                    "path": path,
                    "line": int(line_num),
                    "side": "RIGHT",
                    "body": inline_body
                })

        # Build formatted summary for the review body
        summary_lines = [f"Found **{len(comments)}** issue(s):\n"]
        summary_lines.append("| | File | Issue |")
        summary_lines.append("|---|---|---|")
        for i, c in enumerate(comments, 1):
            path = c.get("path", "")
            line_num = c.get("line", 0)
            body = c.get("body", "").replace("|", "\\|")
            cat = c.get("category", "")
            short_path = path.split("/")[-1] if "/" in path else path
            summary_lines.append(f"| {fmt_category(cat)} | `{short_path}:{line_num}` | {body} |")
        summary_body = "\n".join(summary_lines)

        # Submit PR review with inline comments + summary body
        review_payload = {
            "body": summary_body,
            "event": "COMMENT",
            "commit_id": head_sha,
            "comments": review_comments
        }

        payload_file = "/tmp/ai_review_payload.json"
        with open(payload_file, "w") as f:
            json.dump(review_payload, f)

        result = subprocess.run(
            ["gh", "api", f"repos/{REPOSITORY}/pulls/{PR_NUMBER}/reviews",
             "--input", payload_file, "--method", "POST"],
            capture_output=True, text=True, timeout=120, env={**os.environ}
        )

        if result.returncode != 0:
            print(f"  Review API failed: {result.stderr[:500]}")
            print("  Falling back to summary-only comment...")
            cf = "/tmp/ai_review_comment.md"
            with open(cf, "w") as f:
                f.write(summary_body)
            gh("pr", "comment", PR_NUMBER, "--repo", REPOSITORY, "--body-file", cf)

            posted = len(comments)
        else:
            print(f"  Posted review with {len(review_comments)} inline comment(s) + summary")
            posted = len(review_comments)

        # Always post SHA tracker as issue comment for incremental tracking
        sha_cf = "/tmp/ai_review_sha.md"
        with open(sha_cf, "w") as f:
            f.write(f"<!-- ai-review-sha:{head_sha} -->")
        gh("pr", "comment", PR_NUMBER, "--repo", REPOSITORY, "--body-file", sha_cf)

        out("review_status", "success"); out("comments_posted", str(posted))

        PYEOF

branding:
  icon: 'eye'
  color: 'purple'
