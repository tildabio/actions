name: "Build with Kaniko"
description: "Build a docker container using Kaniko in Kubernetes environment."
inputs:
  service-name:
    description: "Service name"
    required: true
  service-folder:
    description: "Service folder name (defaults to service-name if not provided)"
    required: false
  google-project:
    description: "GCP project to use"
    required: false
    default: "tilda-dev-325721"
  artifactory-url:
    description: "Artifactory URL"
    required: false
    default: "us-central1-docker.pkg.dev"
  github-token:
    description: "GitHub token for repository access"
    required: true
  dockerfile-path:
    description: "Path to Dockerfile relative to service folder"
    required: false
    default: "Dockerfile"
  context-path:
    description: "Build context path"
    required: false
    default: "/workspace/main"
  namespace:
    description: "Kubernetes namespace for Kaniko pod"
    required: false
    default: "gh-runners"
  service-account:
    description: "Kubernetes service account for Kaniko"
    required: false
    default: "kaniko-builder"
  timeout-minutes:
    description: "Timeout for the build in minutes"
    required: false
    default: "45"
  memory-request:
    description: "Memory request for Kaniko container"
    required: false
    default: "8Gi"
  memory-limit:
    description: "Memory limit for Kaniko container"
    required: false
    default: "24Gi"
  cpu-request:
    description: "CPU request for Kaniko container"
    required: false
    default: "4000m"
  cpu-limit:
    description: "CPU limit for Kaniko container"
    required: false
    default: "12"
  enable-cache-registry:
    description: "Enable Kaniko registry-based layer caching"
    required: false
    default: "true"
outputs:
  image-tag:
    description: "Built image tag"
    value: ${{ steps.image-tag.outputs.image_tag }}
  image-url:
    description: "Full image URL"
    value: ${{ steps.image-tag.outputs.image_url }}
runs:
  using: "composite"
  steps:
    - name: Set image tag and service info
      id: image-tag
      shell: bash
      run: |
        # Different detection for push vs PR events vs tag events
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          BRANCH_NAME="${{ github.head_ref }}"
          IMAGE_TAG_BASE="$BRANCH_NAME"
        elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
          TAG_NAME=${GITHUB_REF#refs/tags/}
          IMAGE_TAG_BASE="$TAG_NAME"
        else
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          IMAGE_TAG_BASE="$BRANCH_NAME"
        fi

        GIT_SHA_SHORT=${GITHUB_SHA:0:7}
        IMAGE_TAG="${IMAGE_TAG_BASE}-${GIT_SHA_SHORT}"
        SVC_NAME="${{ inputs.service-name }}"
        SVC_FOLDER="${{ inputs.service-folder }}"

        if [ -z "$SVC_FOLDER" ]; then
          SVC_FOLDER="$SVC_NAME"
        fi

        IMAGE_URL="${{ inputs.artifactory-url }}/${{ inputs.google-project }}/artifacts/services/${SVC_NAME}:${IMAGE_TAG}"

        echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
        echo "svc_name=${SVC_NAME}" >> $GITHUB_OUTPUT
        echo "svc_folder=${SVC_FOLDER}" >> $GITHUB_OUTPUT
        echo "branch_name=${IMAGE_TAG_BASE}" >> $GITHUB_OUTPUT
        echo "image_url=${IMAGE_URL}" >> $GITHUB_OUTPUT

    - name: Build with Kaniko
      shell: bash
      run: |
        cat > kaniko-build.yaml << EOF
        apiVersion: v1
        kind: Pod
        metadata:
          name: kaniko-build-${{ steps.image-tag.outputs.svc_name }}-${{ github.run_id }}
          namespace: ${{ inputs.namespace }}
          labels:
            app: kaniko-build
            service: ${{ inputs.service-name }}
            run-id: "${{ github.run_id }}"
        spec:
          serviceAccountName: ${{ inputs.service-account }}
          restartPolicy: Never
          nodeSelector:
            cloud.google.com/gke-spot: "true"
          initContainers:
          - name: git-clone
            image: bitnami/git:latest
            command:
              - sh
              - -c
              - |
                if [ -z "\${GITHUB_TOKEN}" ] || [ -z "\${REF_NAME}" ]; then
                  echo "❌ Missing required environment variables"
                  exit 1
                fi
                
                case "${{ github.ref }}" in
                  refs/tags/*)
                    git clone "https://x-access-token:\${GITHUB_TOKEN}@github.com/${{ github.repository }}.git" ${{ inputs.context-path }}
                    cd ${{ inputs.context-path }}
                    git fetch --tags
                    git checkout "tags/\${REF_NAME}" || git checkout "\${REF_NAME}"
                    ;;
                  *)
                    git clone --depth 1 --branch "\${REF_NAME}" "https://x-access-token:\${GITHUB_TOKEN}@github.com/${{ github.repository }}.git" ${{ inputs.context-path }}
                    ;;
                esac
            env:
              - name: GITHUB_TOKEN
                value: "${{ inputs.github-token }}"
              - name: REF_NAME
                value: "${{ steps.image-tag.outputs.branch_name }}"
            volumeMounts:
              - name: workspace
                mountPath: /workspace
          - name: setup-cache
            image: alpine:latest
            command:
              - sh
              - -c
              - |
                mkdir -p /build-cache/go/build-cache /build-cache/go/mod /build-cache/python/pip /build-cache/python/poetry /build-cache/apk /build-cache/ccache /build-cache/tools /build-cache/apt
                chmod -R 777 /build-cache
            volumeMounts:
              - name: build-cache
                mountPath: /build-cache
          containers:
          - name: kaniko
            image: gcr.io/kaniko-project/executor:latest
            args:
              - "--context=${{ inputs.context-path }}"
              - "--dockerfile=${{ inputs.context-path }}/${{ steps.image-tag.outputs.svc_folder }}/${{ inputs.dockerfile-path }}"
              - "--destination=${{ steps.image-tag.outputs.image_url }}"
              - "--single-snapshot"
              - "--snapshot-mode=time"
              - "--use-new-run"
              - "--compressed-caching=false"
              - "--ignore-var-run=true"
              - "--push-retry=3"
              - "--build-arg=GOCACHE=/build-cache/go/build-cache"
              - "--build-arg=GOMODCACHE=/build-cache/go/mod"
              - "--build-arg=PIP_CACHE_DIR=/build-cache/python/pip"
              - "--build-arg=POETRY_CACHE_DIR=/build-cache/python/poetry"
              - "--build-arg=APK_CACHE_DIR=/build-cache/apk"
              - "--build-arg=APT_CACHE_DIR=/build-cache/apt"
              - "--build-arg=CCACHE_DIR=/build-cache/ccache"
              - "--build-arg=TOOLS_CACHE_DIR=/build-cache/tools"
            volumeMounts:
              - name: workspace
                mountPath: /workspace
              - name: build-cache
                mountPath: /build-cache
            resources:
              requests:
                memory: "${{ inputs.memory-request }}"
                cpu: "${{ inputs.cpu-request }}"
                ephemeral-storage: "8Gi"
              limits:
                memory: "${{ inputs.memory-limit }}"
                cpu: "${{ inputs.cpu-limit }}"
                ephemeral-storage: "8Gi"
          volumes:
          - name: workspace
            emptyDir: {}
          - name: build-cache
            persistentVolumeClaim:
              claimName: comprehensive-build-cache-${{ inputs.service-name }}
        EOF

        kubectl apply -f kaniko-build.yaml
        kubectl wait --for=condition=Initialized pod/kaniko-build-${{ steps.image-tag.outputs.svc_name }}-${{ github.run_id }} -n ${{ inputs.namespace }} --timeout=300s
        kubectl wait --for=condition=Ready pod/kaniko-build-${{ steps.image-tag.outputs.svc_name }}-${{ github.run_id }} -n ${{ inputs.namespace }} --timeout=60s
        kubectl logs -f pod/kaniko-build-${{ steps.image-tag.outputs.svc_name }}-${{ github.run_id }} -n ${{ inputs.namespace }} -c kaniko

        while true; do
          POD_STATUS=$(kubectl get pod kaniko-build-${{ steps.image-tag.outputs.svc_name }}-${{ github.run_id }} -n ${{ inputs.namespace }} -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
          if [ "$POD_STATUS" = "Succeeded" ] || [ "$POD_STATUS" = "Failed" ]; then
            break
          fi
          sleep 10
        done

        POD_STATUS=$(kubectl get pod kaniko-build-${{ steps.image-tag.outputs.svc_name }}-${{ github.run_id }} -n ${{ inputs.namespace }} -o jsonpath='{.status.phase}')

        if [ "$POD_STATUS" = "Succeeded" ]; then
          echo "✅ Build completed: ${{ steps.image-tag.outputs.image_url }}"
        else
          echo "❌ Build failed with status: $POD_STATUS"
          kubectl logs pod/kaniko-build-${{ steps.image-tag.outputs.svc_name }}-${{ github.run_id }} -n ${{ inputs.namespace }} --all-containers=true || true
          exit 1
        fi

    - name: Cleanup
      if: always()
      shell: bash
      run: |
        kubectl delete pod kaniko-build-${{ steps.image-tag.outputs.svc_name }}-${{ github.run_id }} -n ${{ inputs.namespace }} --ignore-not-found=true
