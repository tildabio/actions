name: "Build and Run Kaniko Pod on K8s cluster"
description: "Build a yaml pod definition from a template and deploys it on a kubernetes cluster"
inputs:
  gh-token:
    description: "GitHub Token"
    required: true
  gh-repo-owner:
    description: "GitHub repo owner name"
    default: tildabio
    required: false
  gh-repo-name:
    description: "GitHub repo name"
    required: false
    default: "main"
  gh-repo-branch-name:
    description: "GitHub repo branch to pull"
    required: false
    default: "master"
  service-folder-name:
    description: "name of the folder within repo where Dockerfile lies"
    required: true
  artifactory-gcr-repo-name:
    description: "name of the gcr repo for the given service."
    required: true
    type: boolean
  artifactory-url:
    description: "url"
    required: false
    default: us-central1-docker.pkg.dev
  artifactory-gcp-project-id:
    description: "GCP of the project where this artifactory repo is present"
    required: false
    default: tilda-dev-325721
  artifactory-path:
    description: path for this image within artifactory repo
    required: true
    default: artifacts/services
  artifactory-image-tag:
    description: image tag
    required: true
  artifactory-cache-repo-name:
    description: location for kaniko to store cache
    required: false
    default: kaniko
  gcloud-service-account:
    description: Service Account in gcloud that can deploy on GKE
    required: false
  gke-cluster:
    description: name of the GKE cluster
    required: true
  gke-cluster-zone:
    description: zone in which gke cluster is deployed
    required: true
  gcp-credentials:
    description: gcp credentials json
    required: true
  pod-namespace:
    description: namespace where pod should be deployed. 
    required: false
    default: default

outputs:
  image:
    description: "Build docker image"
    value: testing custom action
runs:
  using: "composite"
  steps:
    - name: Docker meta
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: |
          ${{ inputs.artifactory-url }}/${{ inputs.artifactory-gcp-project-id }}/artifacts/services/${{ inputs.artifactory-gcr-repo-name }}
        tags: |
          type=sha,enable=true,priority=100,prefix=${{ github.head_ref || github.ref_name}}-,suffix=,format=short

    - name: Create pod manifest from template
      shell: bash
      run: |
        cat > kaniko-pod.yaml <<EOF
        apiVersion: v1
        kind: Pod
        metadata:
          name: ${{ inputs.artifactory-gcr-repo-name }}-kaniko-pod
          namespace: ${{ inputs.pod-namespace }}
        spec:
          nodeSelector:
            workload: arc
          tolerations:
          - key: arc
            operator: "Exists"
            effect: NoSchedule
          initContainers:
          - name: downloadcode
            image: alpine/git
            command:
              - /bin/sh
              - '-c'
              - |
                git clone https://${{ inputs.gh-token }}:x-oauth-basic@github.com/${{ inputs.gh-repo-owner }}/${{ inputs.gh-repo-name }}.git /cache/repo/${{ inputs.gh-repo-name }}
                echo code downloaded.
                cd /cache/repo/${{ inputs.gh-repo-name }}
                git checkout origin/${{ inputs.gh-repo-branch-name }}
                git pull origin ${{ inputs.gh-repo-branch-name }}
                echo branch checked out, initiating copy
                cp -rT /cache/repo/main/ /workspace
                cd /workspace
                git checkout origin/${{ inputs.gh-repo-branch-name }}
                git pull origin ${{ inputs.gh-repo-branch-name }}
                ls -la /workspace/
            volumeMounts:
              - name: workspace
                mountPath: "/workspace"
              - name: modules-volume
                mountPath: /cache
          containers:
          - name: kaniko
            image: gcr.io/kaniko-project/executor:latest
            args:
              - "--dockerfile"
              - "/workspace/${{ inputs.service-folder-name }}/Dockerfile"
              - "--destination" 
              - "${{ steps.meta.outputs.tags }}"
              - "--context"
              - "/workspace/"
              - "--single-snapshot"
              - "--snapshot-mode=redo"
              - "--cache=false"
              - "--cache-dir=/kaniko-cache"
            volumeMounts:
            - name: workspace
              mountPath: "/workspace"  
            - name: modules-volume
              mountPath: /cache
            - name: kaniko-cache
              mountPath: /kaniko-cache
            env:
              - name: GOCACHE
                value: "/cache"
          serviceAccount: kaniko-sa
          restartPolicy: Never
          volumes:
          - name: workspace
            emptyDir: { }
          - name: modules-volume
            persistentVolumeClaim:
              claimName: ${{ inputs.artifactory-gcr-repo-name }}-kaniko-modules-pvc
          - name: kaniko-cache
            persistentVolumeClaim:
              claimName: kaniko-cache
        EOF
        cat kaniko-pod.yaml

    - id: 'auth'
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ inputs.gcp-credentials }}'

    - uses: google-github-actions/get-gke-credentials@db150f2cc60d1716e61922b832eae71d2a45938f
      with:
        cluster_name: ${{ inputs.gke-cluster }}
        location: ${{ inputs.gke-cluster-zone }}
        credentials: ${{ inputs.gcp-credentials }}
        project_id: tilda-trial-dev


    - name: Deploy pod
      shell: bash
      run: |-
        kubectl apply -f kaniko-pod.yaml
    
    - name: Monitor pod status
      shell: bash
      env:
        buildImageName: ${{ inputs.artifactory-gcr-repo-name }}-kaniko-pod
        ns: ${{ inputs.pod-namespace }}
      run: |-
        bash -c '
        while [[ $(kubectl get pods -n $ns $buildImageName -o jsonpath='{..status.phase}') != "Running" && $(kubectl get pods -n $ns $buildImageName  -o jsonpath='{..status.phase}') != "Failed" ]];
        do
          if [ $(kubectl get pods -n $ns $buildImageName  -o jsonpath='{..status.phase}') == "Failed" ]; then
            kubectl logs $buildImageName -n $ns
            # kubectl delete pod -n $ns $buildImageName
            exit 1
          fi
          echo "waiting for pod to initialise" && sleep 1;
        done

        # Monitor for Success or failure
        kubectl logs -n $ns  $buildImageName -f

        if [ $(kubectl get pods -n $ns $buildImageName  -o jsonpath='{..status.phase}') == "Failed" ]; then
          # kubectl delete pod -n $ns $buildImageName
          exit 1
        fi

        # kubectl delete pod -n $ns $buildImageName'